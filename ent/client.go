// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"skillsdemo/ent/migrate"

	"skillsdemo/ent/appointment"
	"skillsdemo/ent/diagnosis"
	"skillsdemo/ent/feedback"
	"skillsdemo/ent/patient"
	"skillsdemo/ent/prompt"
	"skillsdemo/ent/promptresponse"
	"skillsdemo/ent/provider"
	"skillsdemo/ent/survey"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Appointment is the client for interacting with the Appointment builders.
	Appointment *AppointmentClient
	// Diagnosis is the client for interacting with the Diagnosis builders.
	Diagnosis *DiagnosisClient
	// Feedback is the client for interacting with the Feedback builders.
	Feedback *FeedbackClient
	// Patient is the client for interacting with the Patient builders.
	Patient *PatientClient
	// Prompt is the client for interacting with the Prompt builders.
	Prompt *PromptClient
	// PromptResponse is the client for interacting with the PromptResponse builders.
	PromptResponse *PromptResponseClient
	// Provider is the client for interacting with the Provider builders.
	Provider *ProviderClient
	// Survey is the client for interacting with the Survey builders.
	Survey *SurveyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Appointment = NewAppointmentClient(c.config)
	c.Diagnosis = NewDiagnosisClient(c.config)
	c.Feedback = NewFeedbackClient(c.config)
	c.Patient = NewPatientClient(c.config)
	c.Prompt = NewPromptClient(c.config)
	c.PromptResponse = NewPromptResponseClient(c.config)
	c.Provider = NewProviderClient(c.config)
	c.Survey = NewSurveyClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		Appointment:    NewAppointmentClient(cfg),
		Diagnosis:      NewDiagnosisClient(cfg),
		Feedback:       NewFeedbackClient(cfg),
		Patient:        NewPatientClient(cfg),
		Prompt:         NewPromptClient(cfg),
		PromptResponse: NewPromptResponseClient(cfg),
		Provider:       NewProviderClient(cfg),
		Survey:         NewSurveyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		Appointment:    NewAppointmentClient(cfg),
		Diagnosis:      NewDiagnosisClient(cfg),
		Feedback:       NewFeedbackClient(cfg),
		Patient:        NewPatientClient(cfg),
		Prompt:         NewPromptClient(cfg),
		PromptResponse: NewPromptResponseClient(cfg),
		Provider:       NewProviderClient(cfg),
		Survey:         NewSurveyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Appointment.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Appointment, c.Diagnosis, c.Feedback, c.Patient, c.Prompt, c.PromptResponse,
		c.Provider, c.Survey,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Appointment, c.Diagnosis, c.Feedback, c.Patient, c.Prompt, c.PromptResponse,
		c.Provider, c.Survey,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AppointmentMutation:
		return c.Appointment.mutate(ctx, m)
	case *DiagnosisMutation:
		return c.Diagnosis.mutate(ctx, m)
	case *FeedbackMutation:
		return c.Feedback.mutate(ctx, m)
	case *PatientMutation:
		return c.Patient.mutate(ctx, m)
	case *PromptMutation:
		return c.Prompt.mutate(ctx, m)
	case *PromptResponseMutation:
		return c.PromptResponse.mutate(ctx, m)
	case *ProviderMutation:
		return c.Provider.mutate(ctx, m)
	case *SurveyMutation:
		return c.Survey.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AppointmentClient is a client for the Appointment schema.
type AppointmentClient struct {
	config
}

// NewAppointmentClient returns a client for the Appointment from the given config.
func NewAppointmentClient(c config) *AppointmentClient {
	return &AppointmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appointment.Hooks(f(g(h())))`.
func (c *AppointmentClient) Use(hooks ...Hook) {
	c.hooks.Appointment = append(c.hooks.Appointment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appointment.Intercept(f(g(h())))`.
func (c *AppointmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Appointment = append(c.inters.Appointment, interceptors...)
}

// Create returns a builder for creating a Appointment entity.
func (c *AppointmentClient) Create() *AppointmentCreate {
	mutation := newAppointmentMutation(c.config, OpCreate)
	return &AppointmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Appointment entities.
func (c *AppointmentClient) CreateBulk(builders ...*AppointmentCreate) *AppointmentCreateBulk {
	return &AppointmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppointmentClient) MapCreateBulk(slice any, setFunc func(*AppointmentCreate, int)) *AppointmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppointmentCreateBulk{err: fmt.Errorf("calling to AppointmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppointmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppointmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Appointment.
func (c *AppointmentClient) Update() *AppointmentUpdate {
	mutation := newAppointmentMutation(c.config, OpUpdate)
	return &AppointmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppointmentClient) UpdateOne(a *Appointment) *AppointmentUpdateOne {
	mutation := newAppointmentMutation(c.config, OpUpdateOne, withAppointment(a))
	return &AppointmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppointmentClient) UpdateOneID(id uuid.UUID) *AppointmentUpdateOne {
	mutation := newAppointmentMutation(c.config, OpUpdateOne, withAppointmentID(id))
	return &AppointmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Appointment.
func (c *AppointmentClient) Delete() *AppointmentDelete {
	mutation := newAppointmentMutation(c.config, OpDelete)
	return &AppointmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppointmentClient) DeleteOne(a *Appointment) *AppointmentDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppointmentClient) DeleteOneID(id uuid.UUID) *AppointmentDeleteOne {
	builder := c.Delete().Where(appointment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppointmentDeleteOne{builder}
}

// Query returns a query builder for Appointment.
func (c *AppointmentClient) Query() *AppointmentQuery {
	return &AppointmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppointment},
		inters: c.Interceptors(),
	}
}

// Get returns a Appointment entity by its id.
func (c *AppointmentClient) Get(ctx context.Context, id uuid.UUID) (*Appointment, error) {
	return c.Query().Where(appointment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppointmentClient) GetX(ctx context.Context, id uuid.UUID) *Appointment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPatient queries the patient edge of a Appointment.
func (c *AppointmentClient) QueryPatient(a *Appointment) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appointment.Table, appointment.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, appointment.PatientTable, appointment.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvider queries the provider edge of a Appointment.
func (c *AppointmentClient) QueryProvider(a *Appointment) *ProviderQuery {
	query := (&ProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appointment.Table, appointment.FieldID, id),
			sqlgraph.To(provider.Table, provider.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, appointment.ProviderTable, appointment.ProviderColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiagnoses queries the diagnoses edge of a Appointment.
func (c *AppointmentClient) QueryDiagnoses(a *Appointment) *DiagnosisQuery {
	query := (&DiagnosisClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appointment.Table, appointment.FieldID, id),
			sqlgraph.To(diagnosis.Table, diagnosis.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, appointment.DiagnosesTable, appointment.DiagnosesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppointmentClient) Hooks() []Hook {
	return c.hooks.Appointment
}

// Interceptors returns the client interceptors.
func (c *AppointmentClient) Interceptors() []Interceptor {
	return c.inters.Appointment
}

func (c *AppointmentClient) mutate(ctx context.Context, m *AppointmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppointmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppointmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppointmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppointmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Appointment mutation op: %q", m.Op())
	}
}

// DiagnosisClient is a client for the Diagnosis schema.
type DiagnosisClient struct {
	config
}

// NewDiagnosisClient returns a client for the Diagnosis from the given config.
func NewDiagnosisClient(c config) *DiagnosisClient {
	return &DiagnosisClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `diagnosis.Hooks(f(g(h())))`.
func (c *DiagnosisClient) Use(hooks ...Hook) {
	c.hooks.Diagnosis = append(c.hooks.Diagnosis, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `diagnosis.Intercept(f(g(h())))`.
func (c *DiagnosisClient) Intercept(interceptors ...Interceptor) {
	c.inters.Diagnosis = append(c.inters.Diagnosis, interceptors...)
}

// Create returns a builder for creating a Diagnosis entity.
func (c *DiagnosisClient) Create() *DiagnosisCreate {
	mutation := newDiagnosisMutation(c.config, OpCreate)
	return &DiagnosisCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Diagnosis entities.
func (c *DiagnosisClient) CreateBulk(builders ...*DiagnosisCreate) *DiagnosisCreateBulk {
	return &DiagnosisCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiagnosisClient) MapCreateBulk(slice any, setFunc func(*DiagnosisCreate, int)) *DiagnosisCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiagnosisCreateBulk{err: fmt.Errorf("calling to DiagnosisClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiagnosisCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiagnosisCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Diagnosis.
func (c *DiagnosisClient) Update() *DiagnosisUpdate {
	mutation := newDiagnosisMutation(c.config, OpUpdate)
	return &DiagnosisUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiagnosisClient) UpdateOne(d *Diagnosis) *DiagnosisUpdateOne {
	mutation := newDiagnosisMutation(c.config, OpUpdateOne, withDiagnosis(d))
	return &DiagnosisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiagnosisClient) UpdateOneID(id uuid.UUID) *DiagnosisUpdateOne {
	mutation := newDiagnosisMutation(c.config, OpUpdateOne, withDiagnosisID(id))
	return &DiagnosisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Diagnosis.
func (c *DiagnosisClient) Delete() *DiagnosisDelete {
	mutation := newDiagnosisMutation(c.config, OpDelete)
	return &DiagnosisDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiagnosisClient) DeleteOne(d *Diagnosis) *DiagnosisDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiagnosisClient) DeleteOneID(id uuid.UUID) *DiagnosisDeleteOne {
	builder := c.Delete().Where(diagnosis.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiagnosisDeleteOne{builder}
}

// Query returns a query builder for Diagnosis.
func (c *DiagnosisClient) Query() *DiagnosisQuery {
	return &DiagnosisQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDiagnosis},
		inters: c.Interceptors(),
	}
}

// Get returns a Diagnosis entity by its id.
func (c *DiagnosisClient) Get(ctx context.Context, id uuid.UUID) (*Diagnosis, error) {
	return c.Query().Where(diagnosis.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiagnosisClient) GetX(ctx context.Context, id uuid.UUID) *Diagnosis {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAppointment queries the appointment edge of a Diagnosis.
func (c *DiagnosisClient) QueryAppointment(d *Diagnosis) *AppointmentQuery {
	query := (&AppointmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(diagnosis.Table, diagnosis.FieldID, id),
			sqlgraph.To(appointment.Table, appointment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, diagnosis.AppointmentTable, diagnosis.AppointmentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiagnosisClient) Hooks() []Hook {
	return c.hooks.Diagnosis
}

// Interceptors returns the client interceptors.
func (c *DiagnosisClient) Interceptors() []Interceptor {
	return c.inters.Diagnosis
}

func (c *DiagnosisClient) mutate(ctx context.Context, m *DiagnosisMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiagnosisCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiagnosisUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiagnosisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiagnosisDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Diagnosis mutation op: %q", m.Op())
	}
}

// FeedbackClient is a client for the Feedback schema.
type FeedbackClient struct {
	config
}

// NewFeedbackClient returns a client for the Feedback from the given config.
func NewFeedbackClient(c config) *FeedbackClient {
	return &FeedbackClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `feedback.Hooks(f(g(h())))`.
func (c *FeedbackClient) Use(hooks ...Hook) {
	c.hooks.Feedback = append(c.hooks.Feedback, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `feedback.Intercept(f(g(h())))`.
func (c *FeedbackClient) Intercept(interceptors ...Interceptor) {
	c.inters.Feedback = append(c.inters.Feedback, interceptors...)
}

// Create returns a builder for creating a Feedback entity.
func (c *FeedbackClient) Create() *FeedbackCreate {
	mutation := newFeedbackMutation(c.config, OpCreate)
	return &FeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Feedback entities.
func (c *FeedbackClient) CreateBulk(builders ...*FeedbackCreate) *FeedbackCreateBulk {
	return &FeedbackCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeedbackClient) MapCreateBulk(slice any, setFunc func(*FeedbackCreate, int)) *FeedbackCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeedbackCreateBulk{err: fmt.Errorf("calling to FeedbackClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeedbackCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeedbackCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Feedback.
func (c *FeedbackClient) Update() *FeedbackUpdate {
	mutation := newFeedbackMutation(c.config, OpUpdate)
	return &FeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeedbackClient) UpdateOne(f *Feedback) *FeedbackUpdateOne {
	mutation := newFeedbackMutation(c.config, OpUpdateOne, withFeedback(f))
	return &FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeedbackClient) UpdateOneID(id uuid.UUID) *FeedbackUpdateOne {
	mutation := newFeedbackMutation(c.config, OpUpdateOne, withFeedbackID(id))
	return &FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Feedback.
func (c *FeedbackClient) Delete() *FeedbackDelete {
	mutation := newFeedbackMutation(c.config, OpDelete)
	return &FeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeedbackClient) DeleteOne(f *Feedback) *FeedbackDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeedbackClient) DeleteOneID(id uuid.UUID) *FeedbackDeleteOne {
	builder := c.Delete().Where(feedback.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeedbackDeleteOne{builder}
}

// Query returns a query builder for Feedback.
func (c *FeedbackClient) Query() *FeedbackQuery {
	return &FeedbackQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeedback},
		inters: c.Interceptors(),
	}
}

// Get returns a Feedback entity by its id.
func (c *FeedbackClient) Get(ctx context.Context, id uuid.UUID) (*Feedback, error) {
	return c.Query().Where(feedback.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeedbackClient) GetX(ctx context.Context, id uuid.UUID) *Feedback {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResponses queries the responses edge of a Feedback.
func (c *FeedbackClient) QueryResponses(f *Feedback) *PromptResponseQuery {
	query := (&PromptResponseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feedback.Table, feedback.FieldID, id),
			sqlgraph.To(promptresponse.Table, promptresponse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, feedback.ResponsesTable, feedback.ResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeedbackClient) Hooks() []Hook {
	return c.hooks.Feedback
}

// Interceptors returns the client interceptors.
func (c *FeedbackClient) Interceptors() []Interceptor {
	return c.inters.Feedback
}

func (c *FeedbackClient) mutate(ctx context.Context, m *FeedbackMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Feedback mutation op: %q", m.Op())
	}
}

// PatientClient is a client for the Patient schema.
type PatientClient struct {
	config
}

// NewPatientClient returns a client for the Patient from the given config.
func NewPatientClient(c config) *PatientClient {
	return &PatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patient.Hooks(f(g(h())))`.
func (c *PatientClient) Use(hooks ...Hook) {
	c.hooks.Patient = append(c.hooks.Patient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patient.Intercept(f(g(h())))`.
func (c *PatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Patient = append(c.inters.Patient, interceptors...)
}

// Create returns a builder for creating a Patient entity.
func (c *PatientClient) Create() *PatientCreate {
	mutation := newPatientMutation(c.config, OpCreate)
	return &PatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Patient entities.
func (c *PatientClient) CreateBulk(builders ...*PatientCreate) *PatientCreateBulk {
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientClient) MapCreateBulk(slice any, setFunc func(*PatientCreate, int)) *PatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientCreateBulk{err: fmt.Errorf("calling to PatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Patient.
func (c *PatientClient) Update() *PatientUpdate {
	mutation := newPatientMutation(c.config, OpUpdate)
	return &PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientClient) UpdateOne(pa *Patient) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatient(pa))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientClient) UpdateOneID(id uuid.UUID) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatientID(id))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Patient.
func (c *PatientClient) Delete() *PatientDelete {
	mutation := newPatientMutation(c.config, OpDelete)
	return &PatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientClient) DeleteOne(pa *Patient) *PatientDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientClient) DeleteOneID(id uuid.UUID) *PatientDeleteOne {
	builder := c.Delete().Where(patient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientDeleteOne{builder}
}

// Query returns a query builder for Patient.
func (c *PatientClient) Query() *PatientQuery {
	return &PatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Patient entity by its id.
func (c *PatientClient) Get(ctx context.Context, id uuid.UUID) (*Patient, error) {
	return c.Query().Where(patient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientClient) GetX(ctx context.Context, id uuid.UUID) *Patient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAppointments queries the appointments edge of a Patient.
func (c *PatientClient) QueryAppointments(pa *Patient) *AppointmentQuery {
	query := (&AppointmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(appointment.Table, appointment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.AppointmentsTable, patient.AppointmentsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PatientClient) Hooks() []Hook {
	return c.hooks.Patient
}

// Interceptors returns the client interceptors.
func (c *PatientClient) Interceptors() []Interceptor {
	return c.inters.Patient
}

func (c *PatientClient) mutate(ctx context.Context, m *PatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Patient mutation op: %q", m.Op())
	}
}

// PromptClient is a client for the Prompt schema.
type PromptClient struct {
	config
}

// NewPromptClient returns a client for the Prompt from the given config.
func NewPromptClient(c config) *PromptClient {
	return &PromptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prompt.Hooks(f(g(h())))`.
func (c *PromptClient) Use(hooks ...Hook) {
	c.hooks.Prompt = append(c.hooks.Prompt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prompt.Intercept(f(g(h())))`.
func (c *PromptClient) Intercept(interceptors ...Interceptor) {
	c.inters.Prompt = append(c.inters.Prompt, interceptors...)
}

// Create returns a builder for creating a Prompt entity.
func (c *PromptClient) Create() *PromptCreate {
	mutation := newPromptMutation(c.config, OpCreate)
	return &PromptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Prompt entities.
func (c *PromptClient) CreateBulk(builders ...*PromptCreate) *PromptCreateBulk {
	return &PromptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromptClient) MapCreateBulk(slice any, setFunc func(*PromptCreate, int)) *PromptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromptCreateBulk{err: fmt.Errorf("calling to PromptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Prompt.
func (c *PromptClient) Update() *PromptUpdate {
	mutation := newPromptMutation(c.config, OpUpdate)
	return &PromptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromptClient) UpdateOne(pr *Prompt) *PromptUpdateOne {
	mutation := newPromptMutation(c.config, OpUpdateOne, withPrompt(pr))
	return &PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromptClient) UpdateOneID(id uuid.UUID) *PromptUpdateOne {
	mutation := newPromptMutation(c.config, OpUpdateOne, withPromptID(id))
	return &PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Prompt.
func (c *PromptClient) Delete() *PromptDelete {
	mutation := newPromptMutation(c.config, OpDelete)
	return &PromptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromptClient) DeleteOne(pr *Prompt) *PromptDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromptClient) DeleteOneID(id uuid.UUID) *PromptDeleteOne {
	builder := c.Delete().Where(prompt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromptDeleteOne{builder}
}

// Query returns a query builder for Prompt.
func (c *PromptClient) Query() *PromptQuery {
	return &PromptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrompt},
		inters: c.Interceptors(),
	}
}

// Get returns a Prompt entity by its id.
func (c *PromptClient) Get(ctx context.Context, id uuid.UUID) (*Prompt, error) {
	return c.Query().Where(prompt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromptClient) GetX(ctx context.Context, id uuid.UUID) *Prompt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySurvey queries the survey edge of a Prompt.
func (c *PromptClient) QuerySurvey(pr *Prompt) *SurveyQuery {
	query := (&SurveyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prompt.Table, prompt.FieldID, id),
			sqlgraph.To(survey.Table, survey.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, prompt.SurveyTable, prompt.SurveyColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromptClient) Hooks() []Hook {
	return c.hooks.Prompt
}

// Interceptors returns the client interceptors.
func (c *PromptClient) Interceptors() []Interceptor {
	return c.inters.Prompt
}

func (c *PromptClient) mutate(ctx context.Context, m *PromptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Prompt mutation op: %q", m.Op())
	}
}

// PromptResponseClient is a client for the PromptResponse schema.
type PromptResponseClient struct {
	config
}

// NewPromptResponseClient returns a client for the PromptResponse from the given config.
func NewPromptResponseClient(c config) *PromptResponseClient {
	return &PromptResponseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `promptresponse.Hooks(f(g(h())))`.
func (c *PromptResponseClient) Use(hooks ...Hook) {
	c.hooks.PromptResponse = append(c.hooks.PromptResponse, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `promptresponse.Intercept(f(g(h())))`.
func (c *PromptResponseClient) Intercept(interceptors ...Interceptor) {
	c.inters.PromptResponse = append(c.inters.PromptResponse, interceptors...)
}

// Create returns a builder for creating a PromptResponse entity.
func (c *PromptResponseClient) Create() *PromptResponseCreate {
	mutation := newPromptResponseMutation(c.config, OpCreate)
	return &PromptResponseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PromptResponse entities.
func (c *PromptResponseClient) CreateBulk(builders ...*PromptResponseCreate) *PromptResponseCreateBulk {
	return &PromptResponseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromptResponseClient) MapCreateBulk(slice any, setFunc func(*PromptResponseCreate, int)) *PromptResponseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromptResponseCreateBulk{err: fmt.Errorf("calling to PromptResponseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromptResponseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromptResponseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PromptResponse.
func (c *PromptResponseClient) Update() *PromptResponseUpdate {
	mutation := newPromptResponseMutation(c.config, OpUpdate)
	return &PromptResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromptResponseClient) UpdateOne(pr *PromptResponse) *PromptResponseUpdateOne {
	mutation := newPromptResponseMutation(c.config, OpUpdateOne, withPromptResponse(pr))
	return &PromptResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromptResponseClient) UpdateOneID(id uuid.UUID) *PromptResponseUpdateOne {
	mutation := newPromptResponseMutation(c.config, OpUpdateOne, withPromptResponseID(id))
	return &PromptResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PromptResponse.
func (c *PromptResponseClient) Delete() *PromptResponseDelete {
	mutation := newPromptResponseMutation(c.config, OpDelete)
	return &PromptResponseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromptResponseClient) DeleteOne(pr *PromptResponse) *PromptResponseDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromptResponseClient) DeleteOneID(id uuid.UUID) *PromptResponseDeleteOne {
	builder := c.Delete().Where(promptresponse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromptResponseDeleteOne{builder}
}

// Query returns a query builder for PromptResponse.
func (c *PromptResponseClient) Query() *PromptResponseQuery {
	return &PromptResponseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePromptResponse},
		inters: c.Interceptors(),
	}
}

// Get returns a PromptResponse entity by its id.
func (c *PromptResponseClient) Get(ctx context.Context, id uuid.UUID) (*PromptResponse, error) {
	return c.Query().Where(promptresponse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromptResponseClient) GetX(ctx context.Context, id uuid.UUID) *PromptResponse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PromptResponseClient) Hooks() []Hook {
	return c.hooks.PromptResponse
}

// Interceptors returns the client interceptors.
func (c *PromptResponseClient) Interceptors() []Interceptor {
	return c.inters.PromptResponse
}

func (c *PromptResponseClient) mutate(ctx context.Context, m *PromptResponseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromptResponseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromptResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromptResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromptResponseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PromptResponse mutation op: %q", m.Op())
	}
}

// ProviderClient is a client for the Provider schema.
type ProviderClient struct {
	config
}

// NewProviderClient returns a client for the Provider from the given config.
func NewProviderClient(c config) *ProviderClient {
	return &ProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provider.Hooks(f(g(h())))`.
func (c *ProviderClient) Use(hooks ...Hook) {
	c.hooks.Provider = append(c.hooks.Provider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provider.Intercept(f(g(h())))`.
func (c *ProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Provider = append(c.inters.Provider, interceptors...)
}

// Create returns a builder for creating a Provider entity.
func (c *ProviderClient) Create() *ProviderCreate {
	mutation := newProviderMutation(c.config, OpCreate)
	return &ProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Provider entities.
func (c *ProviderClient) CreateBulk(builders ...*ProviderCreate) *ProviderCreateBulk {
	return &ProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderClient) MapCreateBulk(slice any, setFunc func(*ProviderCreate, int)) *ProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderCreateBulk{err: fmt.Errorf("calling to ProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Provider.
func (c *ProviderClient) Update() *ProviderUpdate {
	mutation := newProviderMutation(c.config, OpUpdate)
	return &ProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderClient) UpdateOne(pr *Provider) *ProviderUpdateOne {
	mutation := newProviderMutation(c.config, OpUpdateOne, withProvider(pr))
	return &ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderClient) UpdateOneID(id uuid.UUID) *ProviderUpdateOne {
	mutation := newProviderMutation(c.config, OpUpdateOne, withProviderID(id))
	return &ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Provider.
func (c *ProviderClient) Delete() *ProviderDelete {
	mutation := newProviderMutation(c.config, OpDelete)
	return &ProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderClient) DeleteOne(pr *Provider) *ProviderDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderClient) DeleteOneID(id uuid.UUID) *ProviderDeleteOne {
	builder := c.Delete().Where(provider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderDeleteOne{builder}
}

// Query returns a query builder for Provider.
func (c *ProviderClient) Query() *ProviderQuery {
	return &ProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a Provider entity by its id.
func (c *ProviderClient) Get(ctx context.Context, id uuid.UUID) (*Provider, error) {
	return c.Query().Where(provider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderClient) GetX(ctx context.Context, id uuid.UUID) *Provider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAppointments queries the appointments edge of a Provider.
func (c *ProviderClient) QueryAppointments(pr *Provider) *AppointmentQuery {
	query := (&AppointmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provider.Table, provider.FieldID, id),
			sqlgraph.To(appointment.Table, appointment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, provider.AppointmentsTable, provider.AppointmentsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProviderClient) Hooks() []Hook {
	return c.hooks.Provider
}

// Interceptors returns the client interceptors.
func (c *ProviderClient) Interceptors() []Interceptor {
	return c.inters.Provider
}

func (c *ProviderClient) mutate(ctx context.Context, m *ProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Provider mutation op: %q", m.Op())
	}
}

// SurveyClient is a client for the Survey schema.
type SurveyClient struct {
	config
}

// NewSurveyClient returns a client for the Survey from the given config.
func NewSurveyClient(c config) *SurveyClient {
	return &SurveyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `survey.Hooks(f(g(h())))`.
func (c *SurveyClient) Use(hooks ...Hook) {
	c.hooks.Survey = append(c.hooks.Survey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `survey.Intercept(f(g(h())))`.
func (c *SurveyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Survey = append(c.inters.Survey, interceptors...)
}

// Create returns a builder for creating a Survey entity.
func (c *SurveyClient) Create() *SurveyCreate {
	mutation := newSurveyMutation(c.config, OpCreate)
	return &SurveyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Survey entities.
func (c *SurveyClient) CreateBulk(builders ...*SurveyCreate) *SurveyCreateBulk {
	return &SurveyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SurveyClient) MapCreateBulk(slice any, setFunc func(*SurveyCreate, int)) *SurveyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SurveyCreateBulk{err: fmt.Errorf("calling to SurveyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SurveyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SurveyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Survey.
func (c *SurveyClient) Update() *SurveyUpdate {
	mutation := newSurveyMutation(c.config, OpUpdate)
	return &SurveyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SurveyClient) UpdateOne(s *Survey) *SurveyUpdateOne {
	mutation := newSurveyMutation(c.config, OpUpdateOne, withSurvey(s))
	return &SurveyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SurveyClient) UpdateOneID(id uuid.UUID) *SurveyUpdateOne {
	mutation := newSurveyMutation(c.config, OpUpdateOne, withSurveyID(id))
	return &SurveyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Survey.
func (c *SurveyClient) Delete() *SurveyDelete {
	mutation := newSurveyMutation(c.config, OpDelete)
	return &SurveyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SurveyClient) DeleteOne(s *Survey) *SurveyDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SurveyClient) DeleteOneID(id uuid.UUID) *SurveyDeleteOne {
	builder := c.Delete().Where(survey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SurveyDeleteOne{builder}
}

// Query returns a query builder for Survey.
func (c *SurveyClient) Query() *SurveyQuery {
	return &SurveyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSurvey},
		inters: c.Interceptors(),
	}
}

// Get returns a Survey entity by its id.
func (c *SurveyClient) Get(ctx context.Context, id uuid.UUID) (*Survey, error) {
	return c.Query().Where(survey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SurveyClient) GetX(ctx context.Context, id uuid.UUID) *Survey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrompts queries the prompts edge of a Survey.
func (c *SurveyClient) QueryPrompts(s *Survey) *PromptQuery {
	query := (&PromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(survey.Table, survey.FieldID, id),
			sqlgraph.To(prompt.Table, prompt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, survey.PromptsTable, survey.PromptsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SurveyClient) Hooks() []Hook {
	return c.hooks.Survey
}

// Interceptors returns the client interceptors.
func (c *SurveyClient) Interceptors() []Interceptor {
	return c.inters.Survey
}

func (c *SurveyClient) mutate(ctx context.Context, m *SurveyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SurveyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SurveyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SurveyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SurveyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Survey mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Appointment, Diagnosis, Feedback, Patient, Prompt, PromptResponse, Provider,
		Survey []ent.Hook
	}
	inters struct {
		Appointment, Diagnosis, Feedback, Patient, Prompt, PromptResponse, Provider,
		Survey []ent.Interceptor
	}
)
