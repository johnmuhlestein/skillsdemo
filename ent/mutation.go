// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"skillsdemo/ent/appointment"
	"skillsdemo/ent/diagnosis"
	"skillsdemo/ent/feedback"
	"skillsdemo/ent/patient"
	"skillsdemo/ent/predicate"
	"skillsdemo/ent/prompt"
	"skillsdemo/ent/promptresponse"
	"skillsdemo/ent/provider"
	"skillsdemo/ent/schema"
	"skillsdemo/ent/survey"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointment    = "Appointment"
	TypeDiagnosis      = "Diagnosis"
	TypeFeedback       = "Feedback"
	TypePatient        = "Patient"
	TypePrompt         = "Prompt"
	TypePromptResponse = "PromptResponse"
	TypeProvider       = "Provider"
	TypeSurvey         = "Survey"
)

// AppointmentMutation represents an operation that mutates the Appointment nodes in the graph.
type AppointmentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	status           *string
	period           *schema.Period
	clearedFields    map[string]struct{}
	patient          *uuid.UUID
	clearedpatient   bool
	provider         *uuid.UUID
	clearedprovider  bool
	diagnoses        map[uuid.UUID]struct{}
	removeddiagnoses map[uuid.UUID]struct{}
	cleareddiagnoses bool
	survey           *uuid.UUID
	clearedsurvey    bool
	done             bool
	oldValue         func(context.Context) (*Appointment, error)
	predicates       []predicate.Appointment
}

var _ ent.Mutation = (*AppointmentMutation)(nil)

// appointmentOption allows management of the mutation configuration using functional options.
type appointmentOption func(*AppointmentMutation)

// newAppointmentMutation creates new mutation for the Appointment entity.
func newAppointmentMutation(c config, op Op, opts ...appointmentOption) *AppointmentMutation {
	m := &AppointmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentID sets the ID field of the mutation.
func withAppointmentID(id uuid.UUID) appointmentOption {
	return func(m *AppointmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Appointment
		)
		m.oldValue = func(ctx context.Context) (*Appointment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Appointment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointment sets the old Appointment of the mutation.
func withAppointment(node *Appointment) appointmentOption {
	return func(m *AppointmentMutation) {
		m.oldValue = func(context.Context) (*Appointment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Appointment entities.
func (m *AppointmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppointmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppointmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Appointment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *AppointmentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AppointmentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppointmentMutation) ResetStatus() {
	m.status = nil
}

// SetPeriod sets the "period" field.
func (m *AppointmentMutation) SetPeriod(s schema.Period) {
	m.period = &s
}

// Period returns the value of the "period" field in the mutation.
func (m *AppointmentMutation) Period() (r schema.Period, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldPeriod(ctx context.Context) (v schema.Period, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// ResetPeriod resets all changes to the "period" field.
func (m *AppointmentMutation) ResetPeriod() {
	m.period = nil
}

// SetPatientID sets the "patient" edge to the Patient entity by id.
func (m *AppointmentMutation) SetPatientID(id uuid.UUID) {
	m.patient = &id
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *AppointmentMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *AppointmentMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the "patient" edge ID in the mutation.
func (m *AppointmentMutation) PatientID() (id uuid.UUID, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *AppointmentMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetProviderID sets the "provider" edge to the Provider entity by id.
func (m *AppointmentMutation) SetProviderID(id uuid.UUID) {
	m.provider = &id
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *AppointmentMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *AppointmentMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderID returns the "provider" edge ID in the mutation.
func (m *AppointmentMutation) ProviderID() (id uuid.UUID, exists bool) {
	if m.provider != nil {
		return *m.provider, true
	}
	return
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) ProviderIDs() (ids []uuid.UUID) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *AppointmentMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// AddDiagnosisIDs adds the "diagnoses" edge to the Diagnosis entity by ids.
func (m *AppointmentMutation) AddDiagnosisIDs(ids ...uuid.UUID) {
	if m.diagnoses == nil {
		m.diagnoses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.diagnoses[ids[i]] = struct{}{}
	}
}

// ClearDiagnoses clears the "diagnoses" edge to the Diagnosis entity.
func (m *AppointmentMutation) ClearDiagnoses() {
	m.cleareddiagnoses = true
}

// DiagnosesCleared reports if the "diagnoses" edge to the Diagnosis entity was cleared.
func (m *AppointmentMutation) DiagnosesCleared() bool {
	return m.cleareddiagnoses
}

// RemoveDiagnosisIDs removes the "diagnoses" edge to the Diagnosis entity by IDs.
func (m *AppointmentMutation) RemoveDiagnosisIDs(ids ...uuid.UUID) {
	if m.removeddiagnoses == nil {
		m.removeddiagnoses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.diagnoses, ids[i])
		m.removeddiagnoses[ids[i]] = struct{}{}
	}
}

// RemovedDiagnoses returns the removed IDs of the "diagnoses" edge to the Diagnosis entity.
func (m *AppointmentMutation) RemovedDiagnosesIDs() (ids []uuid.UUID) {
	for id := range m.removeddiagnoses {
		ids = append(ids, id)
	}
	return
}

// DiagnosesIDs returns the "diagnoses" edge IDs in the mutation.
func (m *AppointmentMutation) DiagnosesIDs() (ids []uuid.UUID) {
	for id := range m.diagnoses {
		ids = append(ids, id)
	}
	return
}

// ResetDiagnoses resets all changes to the "diagnoses" edge.
func (m *AppointmentMutation) ResetDiagnoses() {
	m.diagnoses = nil
	m.cleareddiagnoses = false
	m.removeddiagnoses = nil
}

// SetSurveyID sets the "survey" edge to the Survey entity by id.
func (m *AppointmentMutation) SetSurveyID(id uuid.UUID) {
	m.survey = &id
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *AppointmentMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *AppointmentMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the "survey" edge ID in the mutation.
func (m *AppointmentMutation) SurveyID() (id uuid.UUID, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) SurveyIDs() (ids []uuid.UUID) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *AppointmentMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// Where appends a list predicates to the AppointmentMutation builder.
func (m *AppointmentMutation) Where(ps ...predicate.Appointment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppointmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppointmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Appointment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppointmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppointmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Appointment).
func (m *AppointmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppointmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, appointment.FieldStatus)
	}
	if m.period != nil {
		fields = append(fields, appointment.FieldPeriod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppointmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldStatus:
		return m.Status()
	case appointment.FieldPeriod:
		return m.Period()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppointmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointment.FieldStatus:
		return m.OldStatus(ctx)
	case appointment.FieldPeriod:
		return m.OldPeriod(ctx)
	}
	return nil, fmt.Errorf("unknown Appointment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case appointment.FieldPeriod:
		v, ok := value.(schema.Period)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppointmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppointmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Appointment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppointmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppointmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Appointment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppointmentMutation) ResetField(name string) error {
	switch name {
	case appointment.FieldStatus:
		m.ResetStatus()
		return nil
	case appointment.FieldPeriod:
		m.ResetPeriod()
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppointmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.patient != nil {
		edges = append(edges, appointment.EdgePatient)
	}
	if m.provider != nil {
		edges = append(edges, appointment.EdgeProvider)
	}
	if m.diagnoses != nil {
		edges = append(edges, appointment.EdgeDiagnoses)
	}
	if m.survey != nil {
		edges = append(edges, appointment.EdgeSurvey)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppointmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointment.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case appointment.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case appointment.EdgeDiagnoses:
		ids := make([]ent.Value, 0, len(m.diagnoses))
		for id := range m.diagnoses {
			ids = append(ids, id)
		}
		return ids
	case appointment.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppointmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddiagnoses != nil {
		edges = append(edges, appointment.EdgeDiagnoses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppointmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appointment.EdgeDiagnoses:
		ids := make([]ent.Value, 0, len(m.removeddiagnoses))
		for id := range m.removeddiagnoses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppointmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpatient {
		edges = append(edges, appointment.EdgePatient)
	}
	if m.clearedprovider {
		edges = append(edges, appointment.EdgeProvider)
	}
	if m.cleareddiagnoses {
		edges = append(edges, appointment.EdgeDiagnoses)
	}
	if m.clearedsurvey {
		edges = append(edges, appointment.EdgeSurvey)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppointmentMutation) EdgeCleared(name string) bool {
	switch name {
	case appointment.EdgePatient:
		return m.clearedpatient
	case appointment.EdgeProvider:
		return m.clearedprovider
	case appointment.EdgeDiagnoses:
		return m.cleareddiagnoses
	case appointment.EdgeSurvey:
		return m.clearedsurvey
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppointmentMutation) ClearEdge(name string) error {
	switch name {
	case appointment.EdgePatient:
		m.ClearPatient()
		return nil
	case appointment.EdgeProvider:
		m.ClearProvider()
		return nil
	case appointment.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown Appointment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppointmentMutation) ResetEdge(name string) error {
	switch name {
	case appointment.EdgePatient:
		m.ResetPatient()
		return nil
	case appointment.EdgeProvider:
		m.ResetProvider()
		return nil
	case appointment.EdgeDiagnoses:
		m.ResetDiagnoses()
		return nil
	case appointment.EdgeSurvey:
		m.ResetSurvey()
		return nil
	}
	return fmt.Errorf("unknown Appointment edge %s", name)
}

// DiagnosisMutation represents an operation that mutates the Diagnosis nodes in the graph.
type DiagnosisMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	status              *string
	last_updated        *time.Time
	code                *schema.Code
	clearedFields       map[string]struct{}
	appointments        map[uuid.UUID]struct{}
	removedappointments map[uuid.UUID]struct{}
	clearedappointments bool
	done                bool
	oldValue            func(context.Context) (*Diagnosis, error)
	predicates          []predicate.Diagnosis
}

var _ ent.Mutation = (*DiagnosisMutation)(nil)

// diagnosisOption allows management of the mutation configuration using functional options.
type diagnosisOption func(*DiagnosisMutation)

// newDiagnosisMutation creates new mutation for the Diagnosis entity.
func newDiagnosisMutation(c config, op Op, opts ...diagnosisOption) *DiagnosisMutation {
	m := &DiagnosisMutation{
		config:        c,
		op:            op,
		typ:           TypeDiagnosis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiagnosisID sets the ID field of the mutation.
func withDiagnosisID(id uuid.UUID) diagnosisOption {
	return func(m *DiagnosisMutation) {
		var (
			err   error
			once  sync.Once
			value *Diagnosis
		)
		m.oldValue = func(ctx context.Context) (*Diagnosis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Diagnosis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiagnosis sets the old Diagnosis of the mutation.
func withDiagnosis(node *Diagnosis) diagnosisOption {
	return func(m *DiagnosisMutation) {
		m.oldValue = func(context.Context) (*Diagnosis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiagnosisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiagnosisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Diagnosis entities.
func (m *DiagnosisMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiagnosisMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiagnosisMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Diagnosis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *DiagnosisMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DiagnosisMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DiagnosisMutation) ResetStatus() {
	m.status = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *DiagnosisMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *DiagnosisMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *DiagnosisMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetCode sets the "code" field.
func (m *DiagnosisMutation) SetCode(s schema.Code) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DiagnosisMutation) Code() (r schema.Code, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Diagnosis entity.
// If the Diagnosis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosisMutation) OldCode(ctx context.Context) (v schema.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DiagnosisMutation) ResetCode() {
	m.code = nil
}

// AddAppointmentIDs adds the "appointments" edge to the Appointment entity by ids.
func (m *DiagnosisMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointments == nil {
		m.appointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointments[ids[i]] = struct{}{}
	}
}

// ClearAppointments clears the "appointments" edge to the Appointment entity.
func (m *DiagnosisMutation) ClearAppointments() {
	m.clearedappointments = true
}

// AppointmentsCleared reports if the "appointments" edge to the Appointment entity was cleared.
func (m *DiagnosisMutation) AppointmentsCleared() bool {
	return m.clearedappointments
}

// RemoveAppointmentIDs removes the "appointments" edge to the Appointment entity by IDs.
func (m *DiagnosisMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointments == nil {
		m.removedappointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.appointments, ids[i])
		m.removedappointments[ids[i]] = struct{}{}
	}
}

// RemovedAppointments returns the removed IDs of the "appointments" edge to the Appointment entity.
func (m *DiagnosisMutation) RemovedAppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedappointments {
		ids = append(ids, id)
	}
	return
}

// AppointmentsIDs returns the "appointments" edge IDs in the mutation.
func (m *DiagnosisMutation) AppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.appointments {
		ids = append(ids, id)
	}
	return
}

// ResetAppointments resets all changes to the "appointments" edge.
func (m *DiagnosisMutation) ResetAppointments() {
	m.appointments = nil
	m.clearedappointments = false
	m.removedappointments = nil
}

// Where appends a list predicates to the DiagnosisMutation builder.
func (m *DiagnosisMutation) Where(ps ...predicate.Diagnosis) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiagnosisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiagnosisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Diagnosis, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiagnosisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiagnosisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Diagnosis).
func (m *DiagnosisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiagnosisMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, diagnosis.FieldStatus)
	}
	if m.last_updated != nil {
		fields = append(fields, diagnosis.FieldLastUpdated)
	}
	if m.code != nil {
		fields = append(fields, diagnosis.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiagnosisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case diagnosis.FieldStatus:
		return m.Status()
	case diagnosis.FieldLastUpdated:
		return m.LastUpdated()
	case diagnosis.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiagnosisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case diagnosis.FieldStatus:
		return m.OldStatus(ctx)
	case diagnosis.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case diagnosis.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Diagnosis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case diagnosis.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case diagnosis.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case diagnosis.FieldCode:
		v, ok := value.(schema.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Diagnosis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiagnosisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiagnosisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Diagnosis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiagnosisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiagnosisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiagnosisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Diagnosis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiagnosisMutation) ResetField(name string) error {
	switch name {
	case diagnosis.FieldStatus:
		m.ResetStatus()
		return nil
	case diagnosis.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case diagnosis.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiagnosisMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appointments != nil {
		edges = append(edges, diagnosis.EdgeAppointments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiagnosisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case diagnosis.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.appointments))
		for id := range m.appointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiagnosisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedappointments != nil {
		edges = append(edges, diagnosis.EdgeAppointments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiagnosisMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case diagnosis.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.removedappointments))
		for id := range m.removedappointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiagnosisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappointments {
		edges = append(edges, diagnosis.EdgeAppointments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiagnosisMutation) EdgeCleared(name string) bool {
	switch name {
	case diagnosis.EdgeAppointments:
		return m.clearedappointments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiagnosisMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Diagnosis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiagnosisMutation) ResetEdge(name string) error {
	switch name {
	case diagnosis.EdgeAppointments:
		m.ResetAppointments()
		return nil
	}
	return fmt.Errorf("unknown Diagnosis edge %s", name)
}

// FeedbackMutation represents an operation that mutates the Feedback nodes in the graph.
type FeedbackMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	status           *string
	start_time       *time.Time
	completion_time  *time.Time
	clearedFields    map[string]struct{}
	responses        map[uuid.UUID]struct{}
	removedresponses map[uuid.UUID]struct{}
	clearedresponses bool
	patient          *uuid.UUID
	clearedpatient   bool
	survey           *uuid.UUID
	clearedsurvey    bool
	done             bool
	oldValue         func(context.Context) (*Feedback, error)
	predicates       []predicate.Feedback
}

var _ ent.Mutation = (*FeedbackMutation)(nil)

// feedbackOption allows management of the mutation configuration using functional options.
type feedbackOption func(*FeedbackMutation)

// newFeedbackMutation creates new mutation for the Feedback entity.
func newFeedbackMutation(c config, op Op, opts ...feedbackOption) *FeedbackMutation {
	m := &FeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedbackID sets the ID field of the mutation.
func withFeedbackID(id uuid.UUID) feedbackOption {
	return func(m *FeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *Feedback
		)
		m.oldValue = func(ctx context.Context) (*Feedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedback sets the old Feedback of the mutation.
func withFeedback(node *Feedback) feedbackOption {
	return func(m *FeedbackMutation) {
		m.oldValue = func(context.Context) (*Feedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feedback entities.
func (m *FeedbackMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedbackMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedbackMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *FeedbackMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FeedbackMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FeedbackMutation) ResetStatus() {
	m.status = nil
}

// SetStartTime sets the "start_time" field.
func (m *FeedbackMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *FeedbackMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *FeedbackMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[feedback.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *FeedbackMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[feedback.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *FeedbackMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, feedback.FieldStartTime)
}

// SetCompletionTime sets the "completion_time" field.
func (m *FeedbackMutation) SetCompletionTime(t time.Time) {
	m.completion_time = &t
}

// CompletionTime returns the value of the "completion_time" field in the mutation.
func (m *FeedbackMutation) CompletionTime() (r time.Time, exists bool) {
	v := m.completion_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTime returns the old "completion_time" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldCompletionTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTime: %w", err)
	}
	return oldValue.CompletionTime, nil
}

// ClearCompletionTime clears the value of the "completion_time" field.
func (m *FeedbackMutation) ClearCompletionTime() {
	m.completion_time = nil
	m.clearedFields[feedback.FieldCompletionTime] = struct{}{}
}

// CompletionTimeCleared returns if the "completion_time" field was cleared in this mutation.
func (m *FeedbackMutation) CompletionTimeCleared() bool {
	_, ok := m.clearedFields[feedback.FieldCompletionTime]
	return ok
}

// ResetCompletionTime resets all changes to the "completion_time" field.
func (m *FeedbackMutation) ResetCompletionTime() {
	m.completion_time = nil
	delete(m.clearedFields, feedback.FieldCompletionTime)
}

// AddResponseIDs adds the "responses" edge to the PromptResponse entity by ids.
func (m *FeedbackMutation) AddResponseIDs(ids ...uuid.UUID) {
	if m.responses == nil {
		m.responses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.responses[ids[i]] = struct{}{}
	}
}

// ClearResponses clears the "responses" edge to the PromptResponse entity.
func (m *FeedbackMutation) ClearResponses() {
	m.clearedresponses = true
}

// ResponsesCleared reports if the "responses" edge to the PromptResponse entity was cleared.
func (m *FeedbackMutation) ResponsesCleared() bool {
	return m.clearedresponses
}

// RemoveResponseIDs removes the "responses" edge to the PromptResponse entity by IDs.
func (m *FeedbackMutation) RemoveResponseIDs(ids ...uuid.UUID) {
	if m.removedresponses == nil {
		m.removedresponses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.responses, ids[i])
		m.removedresponses[ids[i]] = struct{}{}
	}
}

// RemovedResponses returns the removed IDs of the "responses" edge to the PromptResponse entity.
func (m *FeedbackMutation) RemovedResponsesIDs() (ids []uuid.UUID) {
	for id := range m.removedresponses {
		ids = append(ids, id)
	}
	return
}

// ResponsesIDs returns the "responses" edge IDs in the mutation.
func (m *FeedbackMutation) ResponsesIDs() (ids []uuid.UUID) {
	for id := range m.responses {
		ids = append(ids, id)
	}
	return
}

// ResetResponses resets all changes to the "responses" edge.
func (m *FeedbackMutation) ResetResponses() {
	m.responses = nil
	m.clearedresponses = false
	m.removedresponses = nil
}

// SetPatientID sets the "patient" edge to the Patient entity by id.
func (m *FeedbackMutation) SetPatientID(id uuid.UUID) {
	m.patient = &id
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *FeedbackMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *FeedbackMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the "patient" edge ID in the mutation.
func (m *FeedbackMutation) PatientID() (id uuid.UUID, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *FeedbackMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *FeedbackMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetSurveyID sets the "survey" edge to the Survey entity by id.
func (m *FeedbackMutation) SetSurveyID(id uuid.UUID) {
	m.survey = &id
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *FeedbackMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *FeedbackMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the "survey" edge ID in the mutation.
func (m *FeedbackMutation) SurveyID() (id uuid.UUID, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *FeedbackMutation) SurveyIDs() (ids []uuid.UUID) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *FeedbackMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// Where appends a list predicates to the FeedbackMutation builder.
func (m *FeedbackMutation) Where(ps ...predicate.Feedback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedbackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedbackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feedback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedbackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedbackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feedback).
func (m *FeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedbackMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, feedback.FieldStatus)
	}
	if m.start_time != nil {
		fields = append(fields, feedback.FieldStartTime)
	}
	if m.completion_time != nil {
		fields = append(fields, feedback.FieldCompletionTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldStatus:
		return m.Status()
	case feedback.FieldStartTime:
		return m.StartTime()
	case feedback.FieldCompletionTime:
		return m.CompletionTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedback.FieldStatus:
		return m.OldStatus(ctx)
	case feedback.FieldStartTime:
		return m.OldStartTime(ctx)
	case feedback.FieldCompletionTime:
		return m.OldCompletionTime(ctx)
	}
	return nil, fmt.Errorf("unknown Feedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case feedback.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case feedback.FieldCompletionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTime(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedbackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedbackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feedback.FieldStartTime) {
		fields = append(fields, feedback.FieldStartTime)
	}
	if m.FieldCleared(feedback.FieldCompletionTime) {
		fields = append(fields, feedback.FieldCompletionTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedbackMutation) ClearField(name string) error {
	switch name {
	case feedback.FieldStartTime:
		m.ClearStartTime()
		return nil
	case feedback.FieldCompletionTime:
		m.ClearCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Feedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedbackMutation) ResetField(name string) error {
	switch name {
	case feedback.FieldStatus:
		m.ResetStatus()
		return nil
	case feedback.FieldStartTime:
		m.ResetStartTime()
		return nil
	case feedback.FieldCompletionTime:
		m.ResetCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.responses != nil {
		edges = append(edges, feedback.EdgeResponses)
	}
	if m.patient != nil {
		edges = append(edges, feedback.EdgePatient)
	}
	if m.survey != nil {
		edges = append(edges, feedback.EdgeSurvey)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedback.EdgeResponses:
		ids := make([]ent.Value, 0, len(m.responses))
		for id := range m.responses {
			ids = append(ids, id)
		}
		return ids
	case feedback.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case feedback.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedresponses != nil {
		edges = append(edges, feedback.EdgeResponses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedbackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feedback.EdgeResponses:
		ids := make([]ent.Value, 0, len(m.removedresponses))
		for id := range m.removedresponses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedresponses {
		edges = append(edges, feedback.EdgeResponses)
	}
	if m.clearedpatient {
		edges = append(edges, feedback.EdgePatient)
	}
	if m.clearedsurvey {
		edges = append(edges, feedback.EdgeSurvey)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case feedback.EdgeResponses:
		return m.clearedresponses
	case feedback.EdgePatient:
		return m.clearedpatient
	case feedback.EdgeSurvey:
		return m.clearedsurvey
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedbackMutation) ClearEdge(name string) error {
	switch name {
	case feedback.EdgePatient:
		m.ClearPatient()
		return nil
	case feedback.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown Feedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedbackMutation) ResetEdge(name string) error {
	switch name {
	case feedback.EdgeResponses:
		m.ResetResponses()
		return nil
	case feedback.EdgePatient:
		m.ResetPatient()
		return nil
	case feedback.EdgeSurvey:
		m.ResetSurvey()
		return nil
	}
	return fmt.Errorf("unknown Feedback edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *schema.Name
	gender              *string
	birthdate           *time.Time
	contact             *[]schema.Contact
	appendcontact       []schema.Contact
	address             *[]schema.Address
	appendaddress       []schema.Address
	clearedFields       map[string]struct{}
	appointments        map[uuid.UUID]struct{}
	removedappointments map[uuid.UUID]struct{}
	clearedappointments bool
	feedbacks           map[uuid.UUID]struct{}
	removedfeedbacks    map[uuid.UUID]struct{}
	clearedfeedbacks    bool
	done                bool
	oldValue            func(context.Context) (*Patient, error)
	predicates          []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id uuid.UUID) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Patient entities.
func (m *PatientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Patient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PatientMutation) SetName(s schema.Name) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PatientMutation) Name() (r schema.Name, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldName(ctx context.Context) (v schema.Name, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PatientMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *PatientMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PatientMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *PatientMutation) ResetGender() {
	m.gender = nil
}

// SetBirthdate sets the "birthdate" field.
func (m *PatientMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *PatientMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldBirthdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *PatientMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[patient.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *PatientMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[patient.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *PatientMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, patient.FieldBirthdate)
}

// SetContact sets the "contact" field.
func (m *PatientMutation) SetContact(s []schema.Contact) {
	m.contact = &s
	m.appendcontact = nil
}

// Contact returns the value of the "contact" field in the mutation.
func (m *PatientMutation) Contact() (r []schema.Contact, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldContact(ctx context.Context) (v []schema.Contact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// AppendContact adds s to the "contact" field.
func (m *PatientMutation) AppendContact(s []schema.Contact) {
	m.appendcontact = append(m.appendcontact, s...)
}

// AppendedContact returns the list of values that were appended to the "contact" field in this mutation.
func (m *PatientMutation) AppendedContact() ([]schema.Contact, bool) {
	if len(m.appendcontact) == 0 {
		return nil, false
	}
	return m.appendcontact, true
}

// ClearContact clears the value of the "contact" field.
func (m *PatientMutation) ClearContact() {
	m.contact = nil
	m.appendcontact = nil
	m.clearedFields[patient.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *PatientMutation) ContactCleared() bool {
	_, ok := m.clearedFields[patient.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *PatientMutation) ResetContact() {
	m.contact = nil
	m.appendcontact = nil
	delete(m.clearedFields, patient.FieldContact)
}

// SetAddress sets the "address" field.
func (m *PatientMutation) SetAddress(s []schema.Address) {
	m.address = &s
	m.appendaddress = nil
}

// Address returns the value of the "address" field in the mutation.
func (m *PatientMutation) Address() (r []schema.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldAddress(ctx context.Context) (v []schema.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// AppendAddress adds s to the "address" field.
func (m *PatientMutation) AppendAddress(s []schema.Address) {
	m.appendaddress = append(m.appendaddress, s...)
}

// AppendedAddress returns the list of values that were appended to the "address" field in this mutation.
func (m *PatientMutation) AppendedAddress() ([]schema.Address, bool) {
	if len(m.appendaddress) == 0 {
		return nil, false
	}
	return m.appendaddress, true
}

// ClearAddress clears the value of the "address" field.
func (m *PatientMutation) ClearAddress() {
	m.address = nil
	m.appendaddress = nil
	m.clearedFields[patient.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PatientMutation) AddressCleared() bool {
	_, ok := m.clearedFields[patient.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PatientMutation) ResetAddress() {
	m.address = nil
	m.appendaddress = nil
	delete(m.clearedFields, patient.FieldAddress)
}

// AddAppointmentIDs adds the "appointments" edge to the Appointment entity by ids.
func (m *PatientMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointments == nil {
		m.appointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointments[ids[i]] = struct{}{}
	}
}

// ClearAppointments clears the "appointments" edge to the Appointment entity.
func (m *PatientMutation) ClearAppointments() {
	m.clearedappointments = true
}

// AppointmentsCleared reports if the "appointments" edge to the Appointment entity was cleared.
func (m *PatientMutation) AppointmentsCleared() bool {
	return m.clearedappointments
}

// RemoveAppointmentIDs removes the "appointments" edge to the Appointment entity by IDs.
func (m *PatientMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointments == nil {
		m.removedappointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.appointments, ids[i])
		m.removedappointments[ids[i]] = struct{}{}
	}
}

// RemovedAppointments returns the removed IDs of the "appointments" edge to the Appointment entity.
func (m *PatientMutation) RemovedAppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedappointments {
		ids = append(ids, id)
	}
	return
}

// AppointmentsIDs returns the "appointments" edge IDs in the mutation.
func (m *PatientMutation) AppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.appointments {
		ids = append(ids, id)
	}
	return
}

// ResetAppointments resets all changes to the "appointments" edge.
func (m *PatientMutation) ResetAppointments() {
	m.appointments = nil
	m.clearedappointments = false
	m.removedappointments = nil
}

// AddFeedbackIDs adds the "feedbacks" edge to the Feedback entity by ids.
func (m *PatientMutation) AddFeedbackIDs(ids ...uuid.UUID) {
	if m.feedbacks == nil {
		m.feedbacks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.feedbacks[ids[i]] = struct{}{}
	}
}

// ClearFeedbacks clears the "feedbacks" edge to the Feedback entity.
func (m *PatientMutation) ClearFeedbacks() {
	m.clearedfeedbacks = true
}

// FeedbacksCleared reports if the "feedbacks" edge to the Feedback entity was cleared.
func (m *PatientMutation) FeedbacksCleared() bool {
	return m.clearedfeedbacks
}

// RemoveFeedbackIDs removes the "feedbacks" edge to the Feedback entity by IDs.
func (m *PatientMutation) RemoveFeedbackIDs(ids ...uuid.UUID) {
	if m.removedfeedbacks == nil {
		m.removedfeedbacks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.feedbacks, ids[i])
		m.removedfeedbacks[ids[i]] = struct{}{}
	}
}

// RemovedFeedbacks returns the removed IDs of the "feedbacks" edge to the Feedback entity.
func (m *PatientMutation) RemovedFeedbacksIDs() (ids []uuid.UUID) {
	for id := range m.removedfeedbacks {
		ids = append(ids, id)
	}
	return
}

// FeedbacksIDs returns the "feedbacks" edge IDs in the mutation.
func (m *PatientMutation) FeedbacksIDs() (ids []uuid.UUID) {
	for id := range m.feedbacks {
		ids = append(ids, id)
	}
	return
}

// ResetFeedbacks resets all changes to the "feedbacks" edge.
func (m *PatientMutation) ResetFeedbacks() {
	m.feedbacks = nil
	m.clearedfeedbacks = false
	m.removedfeedbacks = nil
}

// Where appends a list predicates to the PatientMutation builder.
func (m *PatientMutation) Where(ps ...predicate.Patient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Patient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, patient.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, patient.FieldGender)
	}
	if m.birthdate != nil {
		fields = append(fields, patient.FieldBirthdate)
	}
	if m.contact != nil {
		fields = append(fields, patient.FieldContact)
	}
	if m.address != nil {
		fields = append(fields, patient.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldName:
		return m.Name()
	case patient.FieldGender:
		return m.Gender()
	case patient.FieldBirthdate:
		return m.Birthdate()
	case patient.FieldContact:
		return m.Contact()
	case patient.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldName:
		return m.OldName(ctx)
	case patient.FieldGender:
		return m.OldGender(ctx)
	case patient.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case patient.FieldContact:
		return m.OldContact(ctx)
	case patient.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldName:
		v, ok := value.(schema.Name)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case patient.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case patient.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case patient.FieldContact:
		v, ok := value.([]schema.Contact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case patient.FieldAddress:
		v, ok := value.([]schema.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patient.FieldBirthdate) {
		fields = append(fields, patient.FieldBirthdate)
	}
	if m.FieldCleared(patient.FieldContact) {
		fields = append(fields, patient.FieldContact)
	}
	if m.FieldCleared(patient.FieldAddress) {
		fields = append(fields, patient.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	switch name {
	case patient.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case patient.FieldContact:
		m.ClearContact()
		return nil
	case patient.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldName:
		m.ResetName()
		return nil
	case patient.FieldGender:
		m.ResetGender()
		return nil
	case patient.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case patient.FieldContact:
		m.ResetContact()
		return nil
	case patient.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appointments != nil {
		edges = append(edges, patient.EdgeAppointments)
	}
	if m.feedbacks != nil {
		edges = append(edges, patient.EdgeFeedbacks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.appointments))
		for id := range m.appointments {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeFeedbacks:
		ids := make([]ent.Value, 0, len(m.feedbacks))
		for id := range m.feedbacks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedappointments != nil {
		edges = append(edges, patient.EdgeAppointments)
	}
	if m.removedfeedbacks != nil {
		edges = append(edges, patient.EdgeFeedbacks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.removedappointments))
		for id := range m.removedappointments {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeFeedbacks:
		ids := make([]ent.Value, 0, len(m.removedfeedbacks))
		for id := range m.removedfeedbacks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappointments {
		edges = append(edges, patient.EdgeAppointments)
	}
	if m.clearedfeedbacks {
		edges = append(edges, patient.EdgeFeedbacks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeAppointments:
		return m.clearedappointments
	case patient.EdgeFeedbacks:
		return m.clearedfeedbacks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeAppointments:
		m.ResetAppointments()
		return nil
	case patient.EdgeFeedbacks:
		m.ResetFeedbacks()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	sort_order          *int
	addsort_order       *int
	title               *string
	description         *string
	response_type       *schema.Measure
	additional_feedback *bool
	clearedFields       map[string]struct{}
	survey              *uuid.UUID
	clearedsurvey       bool
	done                bool
	oldValue            func(context.Context) (*Prompt, error)
	predicates          []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id uuid.UUID) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Prompt entities.
func (m *PromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSortOrder sets the "sort_order" field.
func (m *PromptMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *PromptMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *PromptMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *PromptMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *PromptMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetTitle sets the "title" field.
func (m *PromptMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PromptMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PromptMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *PromptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PromptMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[prompt.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PromptMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[prompt.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, prompt.FieldDescription)
}

// SetResponseType sets the "response_type" field.
func (m *PromptMutation) SetResponseType(s schema.Measure) {
	m.response_type = &s
}

// ResponseType returns the value of the "response_type" field in the mutation.
func (m *PromptMutation) ResponseType() (r schema.Measure, exists bool) {
	v := m.response_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseType returns the old "response_type" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldResponseType(ctx context.Context) (v schema.Measure, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseType: %w", err)
	}
	return oldValue.ResponseType, nil
}

// ResetResponseType resets all changes to the "response_type" field.
func (m *PromptMutation) ResetResponseType() {
	m.response_type = nil
}

// SetAdditionalFeedback sets the "additional_feedback" field.
func (m *PromptMutation) SetAdditionalFeedback(b bool) {
	m.additional_feedback = &b
}

// AdditionalFeedback returns the value of the "additional_feedback" field in the mutation.
func (m *PromptMutation) AdditionalFeedback() (r bool, exists bool) {
	v := m.additional_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalFeedback returns the old "additional_feedback" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldAdditionalFeedback(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalFeedback: %w", err)
	}
	return oldValue.AdditionalFeedback, nil
}

// ResetAdditionalFeedback resets all changes to the "additional_feedback" field.
func (m *PromptMutation) ResetAdditionalFeedback() {
	m.additional_feedback = nil
}

// SetSurveyID sets the "survey" edge to the Survey entity by id.
func (m *PromptMutation) SetSurveyID(id uuid.UUID) {
	m.survey = &id
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *PromptMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *PromptMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the "survey" edge ID in the mutation.
func (m *PromptMutation) SurveyID() (id uuid.UUID, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *PromptMutation) SurveyIDs() (ids []uuid.UUID) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *PromptMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sort_order != nil {
		fields = append(fields, prompt.FieldSortOrder)
	}
	if m.title != nil {
		fields = append(fields, prompt.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, prompt.FieldDescription)
	}
	if m.response_type != nil {
		fields = append(fields, prompt.FieldResponseType)
	}
	if m.additional_feedback != nil {
		fields = append(fields, prompt.FieldAdditionalFeedback)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldSortOrder:
		return m.SortOrder()
	case prompt.FieldTitle:
		return m.Title()
	case prompt.FieldDescription:
		return m.Description()
	case prompt.FieldResponseType:
		return m.ResponseType()
	case prompt.FieldAdditionalFeedback:
		return m.AdditionalFeedback()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case prompt.FieldTitle:
		return m.OldTitle(ctx)
	case prompt.FieldDescription:
		return m.OldDescription(ctx)
	case prompt.FieldResponseType:
		return m.OldResponseType(ctx)
	case prompt.FieldAdditionalFeedback:
		return m.OldAdditionalFeedback(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case prompt.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case prompt.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompt.FieldResponseType:
		v, ok := value.(schema.Measure)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseType(v)
		return nil
	case prompt.FieldAdditionalFeedback:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalFeedback(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, prompt.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prompt.FieldDescription) {
		fields = append(fields, prompt.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	switch name {
	case prompt.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case prompt.FieldTitle:
		m.ResetTitle()
		return nil
	case prompt.FieldDescription:
		m.ResetDescription()
		return nil
	case prompt.FieldResponseType:
		m.ResetResponseType()
		return nil
	case prompt.FieldAdditionalFeedback:
		m.ResetAdditionalFeedback()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.survey != nil {
		edges = append(edges, prompt.EdgeSurvey)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsurvey {
		edges = append(edges, prompt.EdgeSurvey)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeSurvey:
		return m.clearedsurvey
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	case prompt.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeSurvey:
		m.ResetSurvey()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// PromptResponseMutation represents an operation that mutates the PromptResponse nodes in the graph.
type PromptResponseMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	parsed_template    *string
	prompt_index       *int
	addprompt_index    *int
	range_value        *int
	addrange_value     *int
	bool_value         *string
	enum_value         *schema.MeasureEnum
	label_values       *[]string
	appendlabel_values []string
	freeform_value     *string
	answered_time      *time.Time
	clearedFields      map[string]struct{}
	feedback           *uuid.UUID
	clearedfeedback    bool
	done               bool
	oldValue           func(context.Context) (*PromptResponse, error)
	predicates         []predicate.PromptResponse
}

var _ ent.Mutation = (*PromptResponseMutation)(nil)

// promptresponseOption allows management of the mutation configuration using functional options.
type promptresponseOption func(*PromptResponseMutation)

// newPromptResponseMutation creates new mutation for the PromptResponse entity.
func newPromptResponseMutation(c config, op Op, opts ...promptresponseOption) *PromptResponseMutation {
	m := &PromptResponseMutation{
		config:        c,
		op:            op,
		typ:           TypePromptResponse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptResponseID sets the ID field of the mutation.
func withPromptResponseID(id uuid.UUID) promptresponseOption {
	return func(m *PromptResponseMutation) {
		var (
			err   error
			once  sync.Once
			value *PromptResponse
		)
		m.oldValue = func(ctx context.Context) (*PromptResponse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromptResponse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromptResponse sets the old PromptResponse of the mutation.
func withPromptResponse(node *PromptResponse) promptresponseOption {
	return func(m *PromptResponseMutation) {
		m.oldValue = func(context.Context) (*PromptResponse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptResponseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptResponseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PromptResponse entities.
func (m *PromptResponseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptResponseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptResponseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromptResponse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParsedTemplate sets the "parsed_template" field.
func (m *PromptResponseMutation) SetParsedTemplate(s string) {
	m.parsed_template = &s
}

// ParsedTemplate returns the value of the "parsed_template" field in the mutation.
func (m *PromptResponseMutation) ParsedTemplate() (r string, exists bool) {
	v := m.parsed_template
	if v == nil {
		return
	}
	return *v, true
}

// OldParsedTemplate returns the old "parsed_template" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldParsedTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParsedTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParsedTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParsedTemplate: %w", err)
	}
	return oldValue.ParsedTemplate, nil
}

// ResetParsedTemplate resets all changes to the "parsed_template" field.
func (m *PromptResponseMutation) ResetParsedTemplate() {
	m.parsed_template = nil
}

// SetPromptIndex sets the "prompt_index" field.
func (m *PromptResponseMutation) SetPromptIndex(i int) {
	m.prompt_index = &i
	m.addprompt_index = nil
}

// PromptIndex returns the value of the "prompt_index" field in the mutation.
func (m *PromptResponseMutation) PromptIndex() (r int, exists bool) {
	v := m.prompt_index
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptIndex returns the old "prompt_index" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldPromptIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptIndex: %w", err)
	}
	return oldValue.PromptIndex, nil
}

// AddPromptIndex adds i to the "prompt_index" field.
func (m *PromptResponseMutation) AddPromptIndex(i int) {
	if m.addprompt_index != nil {
		*m.addprompt_index += i
	} else {
		m.addprompt_index = &i
	}
}

// AddedPromptIndex returns the value that was added to the "prompt_index" field in this mutation.
func (m *PromptResponseMutation) AddedPromptIndex() (r int, exists bool) {
	v := m.addprompt_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptIndex resets all changes to the "prompt_index" field.
func (m *PromptResponseMutation) ResetPromptIndex() {
	m.prompt_index = nil
	m.addprompt_index = nil
}

// SetRangeValue sets the "range_value" field.
func (m *PromptResponseMutation) SetRangeValue(i int) {
	m.range_value = &i
	m.addrange_value = nil
}

// RangeValue returns the value of the "range_value" field in the mutation.
func (m *PromptResponseMutation) RangeValue() (r int, exists bool) {
	v := m.range_value
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeValue returns the old "range_value" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldRangeValue(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRangeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRangeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeValue: %w", err)
	}
	return oldValue.RangeValue, nil
}

// AddRangeValue adds i to the "range_value" field.
func (m *PromptResponseMutation) AddRangeValue(i int) {
	if m.addrange_value != nil {
		*m.addrange_value += i
	} else {
		m.addrange_value = &i
	}
}

// AddedRangeValue returns the value that was added to the "range_value" field in this mutation.
func (m *PromptResponseMutation) AddedRangeValue() (r int, exists bool) {
	v := m.addrange_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeValue clears the value of the "range_value" field.
func (m *PromptResponseMutation) ClearRangeValue() {
	m.range_value = nil
	m.addrange_value = nil
	m.clearedFields[promptresponse.FieldRangeValue] = struct{}{}
}

// RangeValueCleared returns if the "range_value" field was cleared in this mutation.
func (m *PromptResponseMutation) RangeValueCleared() bool {
	_, ok := m.clearedFields[promptresponse.FieldRangeValue]
	return ok
}

// ResetRangeValue resets all changes to the "range_value" field.
func (m *PromptResponseMutation) ResetRangeValue() {
	m.range_value = nil
	m.addrange_value = nil
	delete(m.clearedFields, promptresponse.FieldRangeValue)
}

// SetBoolValue sets the "bool_value" field.
func (m *PromptResponseMutation) SetBoolValue(s string) {
	m.bool_value = &s
}

// BoolValue returns the value of the "bool_value" field in the mutation.
func (m *PromptResponseMutation) BoolValue() (r string, exists bool) {
	v := m.bool_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolValue returns the old "bool_value" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldBoolValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoolValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoolValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolValue: %w", err)
	}
	return oldValue.BoolValue, nil
}

// ClearBoolValue clears the value of the "bool_value" field.
func (m *PromptResponseMutation) ClearBoolValue() {
	m.bool_value = nil
	m.clearedFields[promptresponse.FieldBoolValue] = struct{}{}
}

// BoolValueCleared returns if the "bool_value" field was cleared in this mutation.
func (m *PromptResponseMutation) BoolValueCleared() bool {
	_, ok := m.clearedFields[promptresponse.FieldBoolValue]
	return ok
}

// ResetBoolValue resets all changes to the "bool_value" field.
func (m *PromptResponseMutation) ResetBoolValue() {
	m.bool_value = nil
	delete(m.clearedFields, promptresponse.FieldBoolValue)
}

// SetEnumValue sets the "enum_value" field.
func (m *PromptResponseMutation) SetEnumValue(se schema.MeasureEnum) {
	m.enum_value = &se
}

// EnumValue returns the value of the "enum_value" field in the mutation.
func (m *PromptResponseMutation) EnumValue() (r schema.MeasureEnum, exists bool) {
	v := m.enum_value
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValue returns the old "enum_value" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldEnumValue(ctx context.Context) (v schema.MeasureEnum, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnumValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnumValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValue: %w", err)
	}
	return oldValue.EnumValue, nil
}

// ClearEnumValue clears the value of the "enum_value" field.
func (m *PromptResponseMutation) ClearEnumValue() {
	m.enum_value = nil
	m.clearedFields[promptresponse.FieldEnumValue] = struct{}{}
}

// EnumValueCleared returns if the "enum_value" field was cleared in this mutation.
func (m *PromptResponseMutation) EnumValueCleared() bool {
	_, ok := m.clearedFields[promptresponse.FieldEnumValue]
	return ok
}

// ResetEnumValue resets all changes to the "enum_value" field.
func (m *PromptResponseMutation) ResetEnumValue() {
	m.enum_value = nil
	delete(m.clearedFields, promptresponse.FieldEnumValue)
}

// SetLabelValues sets the "label_values" field.
func (m *PromptResponseMutation) SetLabelValues(s []string) {
	m.label_values = &s
	m.appendlabel_values = nil
}

// LabelValues returns the value of the "label_values" field in the mutation.
func (m *PromptResponseMutation) LabelValues() (r []string, exists bool) {
	v := m.label_values
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelValues returns the old "label_values" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldLabelValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelValues: %w", err)
	}
	return oldValue.LabelValues, nil
}

// AppendLabelValues adds s to the "label_values" field.
func (m *PromptResponseMutation) AppendLabelValues(s []string) {
	m.appendlabel_values = append(m.appendlabel_values, s...)
}

// AppendedLabelValues returns the list of values that were appended to the "label_values" field in this mutation.
func (m *PromptResponseMutation) AppendedLabelValues() ([]string, bool) {
	if len(m.appendlabel_values) == 0 {
		return nil, false
	}
	return m.appendlabel_values, true
}

// ClearLabelValues clears the value of the "label_values" field.
func (m *PromptResponseMutation) ClearLabelValues() {
	m.label_values = nil
	m.appendlabel_values = nil
	m.clearedFields[promptresponse.FieldLabelValues] = struct{}{}
}

// LabelValuesCleared returns if the "label_values" field was cleared in this mutation.
func (m *PromptResponseMutation) LabelValuesCleared() bool {
	_, ok := m.clearedFields[promptresponse.FieldLabelValues]
	return ok
}

// ResetLabelValues resets all changes to the "label_values" field.
func (m *PromptResponseMutation) ResetLabelValues() {
	m.label_values = nil
	m.appendlabel_values = nil
	delete(m.clearedFields, promptresponse.FieldLabelValues)
}

// SetFreeformValue sets the "freeform_value" field.
func (m *PromptResponseMutation) SetFreeformValue(s string) {
	m.freeform_value = &s
}

// FreeformValue returns the value of the "freeform_value" field in the mutation.
func (m *PromptResponseMutation) FreeformValue() (r string, exists bool) {
	v := m.freeform_value
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeformValue returns the old "freeform_value" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldFreeformValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeformValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeformValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeformValue: %w", err)
	}
	return oldValue.FreeformValue, nil
}

// ClearFreeformValue clears the value of the "freeform_value" field.
func (m *PromptResponseMutation) ClearFreeformValue() {
	m.freeform_value = nil
	m.clearedFields[promptresponse.FieldFreeformValue] = struct{}{}
}

// FreeformValueCleared returns if the "freeform_value" field was cleared in this mutation.
func (m *PromptResponseMutation) FreeformValueCleared() bool {
	_, ok := m.clearedFields[promptresponse.FieldFreeformValue]
	return ok
}

// ResetFreeformValue resets all changes to the "freeform_value" field.
func (m *PromptResponseMutation) ResetFreeformValue() {
	m.freeform_value = nil
	delete(m.clearedFields, promptresponse.FieldFreeformValue)
}

// SetAnsweredTime sets the "answered_time" field.
func (m *PromptResponseMutation) SetAnsweredTime(t time.Time) {
	m.answered_time = &t
}

// AnsweredTime returns the value of the "answered_time" field in the mutation.
func (m *PromptResponseMutation) AnsweredTime() (r time.Time, exists bool) {
	v := m.answered_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAnsweredTime returns the old "answered_time" field's value of the PromptResponse entity.
// If the PromptResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptResponseMutation) OldAnsweredTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnsweredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnsweredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnsweredTime: %w", err)
	}
	return oldValue.AnsweredTime, nil
}

// ClearAnsweredTime clears the value of the "answered_time" field.
func (m *PromptResponseMutation) ClearAnsweredTime() {
	m.answered_time = nil
	m.clearedFields[promptresponse.FieldAnsweredTime] = struct{}{}
}

// AnsweredTimeCleared returns if the "answered_time" field was cleared in this mutation.
func (m *PromptResponseMutation) AnsweredTimeCleared() bool {
	_, ok := m.clearedFields[promptresponse.FieldAnsweredTime]
	return ok
}

// ResetAnsweredTime resets all changes to the "answered_time" field.
func (m *PromptResponseMutation) ResetAnsweredTime() {
	m.answered_time = nil
	delete(m.clearedFields, promptresponse.FieldAnsweredTime)
}

// SetFeedbackID sets the "feedback" edge to the Feedback entity by id.
func (m *PromptResponseMutation) SetFeedbackID(id uuid.UUID) {
	m.feedback = &id
}

// ClearFeedback clears the "feedback" edge to the Feedback entity.
func (m *PromptResponseMutation) ClearFeedback() {
	m.clearedfeedback = true
}

// FeedbackCleared reports if the "feedback" edge to the Feedback entity was cleared.
func (m *PromptResponseMutation) FeedbackCleared() bool {
	return m.clearedfeedback
}

// FeedbackID returns the "feedback" edge ID in the mutation.
func (m *PromptResponseMutation) FeedbackID() (id uuid.UUID, exists bool) {
	if m.feedback != nil {
		return *m.feedback, true
	}
	return
}

// FeedbackIDs returns the "feedback" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedbackID instead. It exists only for internal usage by the builders.
func (m *PromptResponseMutation) FeedbackIDs() (ids []uuid.UUID) {
	if id := m.feedback; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedback resets all changes to the "feedback" edge.
func (m *PromptResponseMutation) ResetFeedback() {
	m.feedback = nil
	m.clearedfeedback = false
}

// Where appends a list predicates to the PromptResponseMutation builder.
func (m *PromptResponseMutation) Where(ps ...predicate.PromptResponse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptResponseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptResponseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromptResponse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptResponseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptResponseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromptResponse).
func (m *PromptResponseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptResponseMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.parsed_template != nil {
		fields = append(fields, promptresponse.FieldParsedTemplate)
	}
	if m.prompt_index != nil {
		fields = append(fields, promptresponse.FieldPromptIndex)
	}
	if m.range_value != nil {
		fields = append(fields, promptresponse.FieldRangeValue)
	}
	if m.bool_value != nil {
		fields = append(fields, promptresponse.FieldBoolValue)
	}
	if m.enum_value != nil {
		fields = append(fields, promptresponse.FieldEnumValue)
	}
	if m.label_values != nil {
		fields = append(fields, promptresponse.FieldLabelValues)
	}
	if m.freeform_value != nil {
		fields = append(fields, promptresponse.FieldFreeformValue)
	}
	if m.answered_time != nil {
		fields = append(fields, promptresponse.FieldAnsweredTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptResponseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promptresponse.FieldParsedTemplate:
		return m.ParsedTemplate()
	case promptresponse.FieldPromptIndex:
		return m.PromptIndex()
	case promptresponse.FieldRangeValue:
		return m.RangeValue()
	case promptresponse.FieldBoolValue:
		return m.BoolValue()
	case promptresponse.FieldEnumValue:
		return m.EnumValue()
	case promptresponse.FieldLabelValues:
		return m.LabelValues()
	case promptresponse.FieldFreeformValue:
		return m.FreeformValue()
	case promptresponse.FieldAnsweredTime:
		return m.AnsweredTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptResponseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promptresponse.FieldParsedTemplate:
		return m.OldParsedTemplate(ctx)
	case promptresponse.FieldPromptIndex:
		return m.OldPromptIndex(ctx)
	case promptresponse.FieldRangeValue:
		return m.OldRangeValue(ctx)
	case promptresponse.FieldBoolValue:
		return m.OldBoolValue(ctx)
	case promptresponse.FieldEnumValue:
		return m.OldEnumValue(ctx)
	case promptresponse.FieldLabelValues:
		return m.OldLabelValues(ctx)
	case promptresponse.FieldFreeformValue:
		return m.OldFreeformValue(ctx)
	case promptresponse.FieldAnsweredTime:
		return m.OldAnsweredTime(ctx)
	}
	return nil, fmt.Errorf("unknown PromptResponse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptResponseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promptresponse.FieldParsedTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParsedTemplate(v)
		return nil
	case promptresponse.FieldPromptIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptIndex(v)
		return nil
	case promptresponse.FieldRangeValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeValue(v)
		return nil
	case promptresponse.FieldBoolValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolValue(v)
		return nil
	case promptresponse.FieldEnumValue:
		v, ok := value.(schema.MeasureEnum)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValue(v)
		return nil
	case promptresponse.FieldLabelValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelValues(v)
		return nil
	case promptresponse.FieldFreeformValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeformValue(v)
		return nil
	case promptresponse.FieldAnsweredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnsweredTime(v)
		return nil
	}
	return fmt.Errorf("unknown PromptResponse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptResponseMutation) AddedFields() []string {
	var fields []string
	if m.addprompt_index != nil {
		fields = append(fields, promptresponse.FieldPromptIndex)
	}
	if m.addrange_value != nil {
		fields = append(fields, promptresponse.FieldRangeValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptResponseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promptresponse.FieldPromptIndex:
		return m.AddedPromptIndex()
	case promptresponse.FieldRangeValue:
		return m.AddedRangeValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptResponseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promptresponse.FieldPromptIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptIndex(v)
		return nil
	case promptresponse.FieldRangeValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeValue(v)
		return nil
	}
	return fmt.Errorf("unknown PromptResponse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptResponseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promptresponse.FieldRangeValue) {
		fields = append(fields, promptresponse.FieldRangeValue)
	}
	if m.FieldCleared(promptresponse.FieldBoolValue) {
		fields = append(fields, promptresponse.FieldBoolValue)
	}
	if m.FieldCleared(promptresponse.FieldEnumValue) {
		fields = append(fields, promptresponse.FieldEnumValue)
	}
	if m.FieldCleared(promptresponse.FieldLabelValues) {
		fields = append(fields, promptresponse.FieldLabelValues)
	}
	if m.FieldCleared(promptresponse.FieldFreeformValue) {
		fields = append(fields, promptresponse.FieldFreeformValue)
	}
	if m.FieldCleared(promptresponse.FieldAnsweredTime) {
		fields = append(fields, promptresponse.FieldAnsweredTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptResponseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptResponseMutation) ClearField(name string) error {
	switch name {
	case promptresponse.FieldRangeValue:
		m.ClearRangeValue()
		return nil
	case promptresponse.FieldBoolValue:
		m.ClearBoolValue()
		return nil
	case promptresponse.FieldEnumValue:
		m.ClearEnumValue()
		return nil
	case promptresponse.FieldLabelValues:
		m.ClearLabelValues()
		return nil
	case promptresponse.FieldFreeformValue:
		m.ClearFreeformValue()
		return nil
	case promptresponse.FieldAnsweredTime:
		m.ClearAnsweredTime()
		return nil
	}
	return fmt.Errorf("unknown PromptResponse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptResponseMutation) ResetField(name string) error {
	switch name {
	case promptresponse.FieldParsedTemplate:
		m.ResetParsedTemplate()
		return nil
	case promptresponse.FieldPromptIndex:
		m.ResetPromptIndex()
		return nil
	case promptresponse.FieldRangeValue:
		m.ResetRangeValue()
		return nil
	case promptresponse.FieldBoolValue:
		m.ResetBoolValue()
		return nil
	case promptresponse.FieldEnumValue:
		m.ResetEnumValue()
		return nil
	case promptresponse.FieldLabelValues:
		m.ResetLabelValues()
		return nil
	case promptresponse.FieldFreeformValue:
		m.ResetFreeformValue()
		return nil
	case promptresponse.FieldAnsweredTime:
		m.ResetAnsweredTime()
		return nil
	}
	return fmt.Errorf("unknown PromptResponse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptResponseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.feedback != nil {
		edges = append(edges, promptresponse.EdgeFeedback)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptResponseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promptresponse.EdgeFeedback:
		if id := m.feedback; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptResponseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptResponseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptResponseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfeedback {
		edges = append(edges, promptresponse.EdgeFeedback)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptResponseMutation) EdgeCleared(name string) bool {
	switch name {
	case promptresponse.EdgeFeedback:
		return m.clearedfeedback
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptResponseMutation) ClearEdge(name string) error {
	switch name {
	case promptresponse.EdgeFeedback:
		m.ClearFeedback()
		return nil
	}
	return fmt.Errorf("unknown PromptResponse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptResponseMutation) ResetEdge(name string) error {
	switch name {
	case promptresponse.EdgeFeedback:
		m.ResetFeedback()
		return nil
	}
	return fmt.Errorf("unknown PromptResponse edge %s", name)
}

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *schema.Name
	clearedFields       map[string]struct{}
	appointments        map[uuid.UUID]struct{}
	removedappointments map[uuid.UUID]struct{}
	clearedappointments bool
	done                bool
	oldValue            func(context.Context) (*Provider, error)
	predicates          []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id uuid.UUID) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Provider entities.
func (m *ProviderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProviderMutation) SetName(s schema.Name) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderMutation) Name() (r schema.Name, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldName(ctx context.Context) (v schema.Name, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderMutation) ResetName() {
	m.name = nil
}

// AddAppointmentIDs adds the "appointments" edge to the Appointment entity by ids.
func (m *ProviderMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointments == nil {
		m.appointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointments[ids[i]] = struct{}{}
	}
}

// ClearAppointments clears the "appointments" edge to the Appointment entity.
func (m *ProviderMutation) ClearAppointments() {
	m.clearedappointments = true
}

// AppointmentsCleared reports if the "appointments" edge to the Appointment entity was cleared.
func (m *ProviderMutation) AppointmentsCleared() bool {
	return m.clearedappointments
}

// RemoveAppointmentIDs removes the "appointments" edge to the Appointment entity by IDs.
func (m *ProviderMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointments == nil {
		m.removedappointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.appointments, ids[i])
		m.removedappointments[ids[i]] = struct{}{}
	}
}

// RemovedAppointments returns the removed IDs of the "appointments" edge to the Appointment entity.
func (m *ProviderMutation) RemovedAppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedappointments {
		ids = append(ids, id)
	}
	return
}

// AppointmentsIDs returns the "appointments" edge IDs in the mutation.
func (m *ProviderMutation) AppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.appointments {
		ids = append(ids, id)
	}
	return
}

// ResetAppointments resets all changes to the "appointments" edge.
func (m *ProviderMutation) ResetAppointments() {
	m.appointments = nil
	m.clearedappointments = false
	m.removedappointments = nil
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, provider.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldName:
		v, ok := value.(schema.Name)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appointments != nil {
		edges = append(edges, provider.EdgeAppointments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.appointments))
		for id := range m.appointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedappointments != nil {
		edges = append(edges, provider.EdgeAppointments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.removedappointments))
		for id := range m.removedappointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappointments {
		edges = append(edges, provider.EdgeAppointments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case provider.EdgeAppointments:
		return m.clearedappointments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	switch name {
	case provider.EdgeAppointments:
		m.ResetAppointments()
		return nil
	}
	return fmt.Errorf("unknown Provider edge %s", name)
}

// SurveyMutation represents an operation that mutates the Survey nodes in the graph.
type SurveyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	title               *string
	description         *string
	status              *survey.Status
	active_time         *time.Time
	archive_time        *time.Time
	clearedFields       map[string]struct{}
	prompts             map[uuid.UUID]struct{}
	removedprompts      map[uuid.UUID]struct{}
	clearedprompts      bool
	feedbacks           map[uuid.UUID]struct{}
	removedfeedbacks    map[uuid.UUID]struct{}
	clearedfeedbacks    bool
	appointments        map[uuid.UUID]struct{}
	removedappointments map[uuid.UUID]struct{}
	clearedappointments bool
	done                bool
	oldValue            func(context.Context) (*Survey, error)
	predicates          []predicate.Survey
}

var _ ent.Mutation = (*SurveyMutation)(nil)

// surveyOption allows management of the mutation configuration using functional options.
type surveyOption func(*SurveyMutation)

// newSurveyMutation creates new mutation for the Survey entity.
func newSurveyMutation(c config, op Op, opts ...surveyOption) *SurveyMutation {
	m := &SurveyMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyID sets the ID field of the mutation.
func withSurveyID(id uuid.UUID) surveyOption {
	return func(m *SurveyMutation) {
		var (
			err   error
			once  sync.Once
			value *Survey
		)
		m.oldValue = func(ctx context.Context) (*Survey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Survey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurvey sets the old Survey of the mutation.
func withSurvey(node *Survey) surveyOption {
	return func(m *SurveyMutation) {
		m.oldValue = func(context.Context) (*Survey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Survey entities.
func (m *SurveyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Survey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *SurveyMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SurveyMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SurveyMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *SurveyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SurveyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SurveyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[survey.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SurveyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[survey.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SurveyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, survey.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *SurveyMutation) SetStatus(s survey.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyMutation) Status() (r survey.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldStatus(ctx context.Context) (v survey.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyMutation) ResetStatus() {
	m.status = nil
}

// SetActiveTime sets the "active_time" field.
func (m *SurveyMutation) SetActiveTime(t time.Time) {
	m.active_time = &t
}

// ActiveTime returns the value of the "active_time" field in the mutation.
func (m *SurveyMutation) ActiveTime() (r time.Time, exists bool) {
	v := m.active_time
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTime returns the old "active_time" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldActiveTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTime: %w", err)
	}
	return oldValue.ActiveTime, nil
}

// ClearActiveTime clears the value of the "active_time" field.
func (m *SurveyMutation) ClearActiveTime() {
	m.active_time = nil
	m.clearedFields[survey.FieldActiveTime] = struct{}{}
}

// ActiveTimeCleared returns if the "active_time" field was cleared in this mutation.
func (m *SurveyMutation) ActiveTimeCleared() bool {
	_, ok := m.clearedFields[survey.FieldActiveTime]
	return ok
}

// ResetActiveTime resets all changes to the "active_time" field.
func (m *SurveyMutation) ResetActiveTime() {
	m.active_time = nil
	delete(m.clearedFields, survey.FieldActiveTime)
}

// SetArchiveTime sets the "archive_time" field.
func (m *SurveyMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *SurveyMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldArchiveTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *SurveyMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[survey.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *SurveyMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[survey.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *SurveyMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, survey.FieldArchiveTime)
}

// AddPromptIDs adds the "prompts" edge to the Prompt entity by ids.
func (m *SurveyMutation) AddPromptIDs(ids ...uuid.UUID) {
	if m.prompts == nil {
		m.prompts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.prompts[ids[i]] = struct{}{}
	}
}

// ClearPrompts clears the "prompts" edge to the Prompt entity.
func (m *SurveyMutation) ClearPrompts() {
	m.clearedprompts = true
}

// PromptsCleared reports if the "prompts" edge to the Prompt entity was cleared.
func (m *SurveyMutation) PromptsCleared() bool {
	return m.clearedprompts
}

// RemovePromptIDs removes the "prompts" edge to the Prompt entity by IDs.
func (m *SurveyMutation) RemovePromptIDs(ids ...uuid.UUID) {
	if m.removedprompts == nil {
		m.removedprompts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.prompts, ids[i])
		m.removedprompts[ids[i]] = struct{}{}
	}
}

// RemovedPrompts returns the removed IDs of the "prompts" edge to the Prompt entity.
func (m *SurveyMutation) RemovedPromptsIDs() (ids []uuid.UUID) {
	for id := range m.removedprompts {
		ids = append(ids, id)
	}
	return
}

// PromptsIDs returns the "prompts" edge IDs in the mutation.
func (m *SurveyMutation) PromptsIDs() (ids []uuid.UUID) {
	for id := range m.prompts {
		ids = append(ids, id)
	}
	return
}

// ResetPrompts resets all changes to the "prompts" edge.
func (m *SurveyMutation) ResetPrompts() {
	m.prompts = nil
	m.clearedprompts = false
	m.removedprompts = nil
}

// AddFeedbackIDs adds the "feedbacks" edge to the Feedback entity by ids.
func (m *SurveyMutation) AddFeedbackIDs(ids ...uuid.UUID) {
	if m.feedbacks == nil {
		m.feedbacks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.feedbacks[ids[i]] = struct{}{}
	}
}

// ClearFeedbacks clears the "feedbacks" edge to the Feedback entity.
func (m *SurveyMutation) ClearFeedbacks() {
	m.clearedfeedbacks = true
}

// FeedbacksCleared reports if the "feedbacks" edge to the Feedback entity was cleared.
func (m *SurveyMutation) FeedbacksCleared() bool {
	return m.clearedfeedbacks
}

// RemoveFeedbackIDs removes the "feedbacks" edge to the Feedback entity by IDs.
func (m *SurveyMutation) RemoveFeedbackIDs(ids ...uuid.UUID) {
	if m.removedfeedbacks == nil {
		m.removedfeedbacks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.feedbacks, ids[i])
		m.removedfeedbacks[ids[i]] = struct{}{}
	}
}

// RemovedFeedbacks returns the removed IDs of the "feedbacks" edge to the Feedback entity.
func (m *SurveyMutation) RemovedFeedbacksIDs() (ids []uuid.UUID) {
	for id := range m.removedfeedbacks {
		ids = append(ids, id)
	}
	return
}

// FeedbacksIDs returns the "feedbacks" edge IDs in the mutation.
func (m *SurveyMutation) FeedbacksIDs() (ids []uuid.UUID) {
	for id := range m.feedbacks {
		ids = append(ids, id)
	}
	return
}

// ResetFeedbacks resets all changes to the "feedbacks" edge.
func (m *SurveyMutation) ResetFeedbacks() {
	m.feedbacks = nil
	m.clearedfeedbacks = false
	m.removedfeedbacks = nil
}

// AddAppointmentIDs adds the "appointments" edge to the Appointment entity by ids.
func (m *SurveyMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointments == nil {
		m.appointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointments[ids[i]] = struct{}{}
	}
}

// ClearAppointments clears the "appointments" edge to the Appointment entity.
func (m *SurveyMutation) ClearAppointments() {
	m.clearedappointments = true
}

// AppointmentsCleared reports if the "appointments" edge to the Appointment entity was cleared.
func (m *SurveyMutation) AppointmentsCleared() bool {
	return m.clearedappointments
}

// RemoveAppointmentIDs removes the "appointments" edge to the Appointment entity by IDs.
func (m *SurveyMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointments == nil {
		m.removedappointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.appointments, ids[i])
		m.removedappointments[ids[i]] = struct{}{}
	}
}

// RemovedAppointments returns the removed IDs of the "appointments" edge to the Appointment entity.
func (m *SurveyMutation) RemovedAppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedappointments {
		ids = append(ids, id)
	}
	return
}

// AppointmentsIDs returns the "appointments" edge IDs in the mutation.
func (m *SurveyMutation) AppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.appointments {
		ids = append(ids, id)
	}
	return
}

// ResetAppointments resets all changes to the "appointments" edge.
func (m *SurveyMutation) ResetAppointments() {
	m.appointments = nil
	m.clearedappointments = false
	m.removedappointments = nil
}

// Where appends a list predicates to the SurveyMutation builder.
func (m *SurveyMutation) Where(ps ...predicate.Survey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Survey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Survey).
func (m *SurveyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, survey.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, survey.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, survey.FieldStatus)
	}
	if m.active_time != nil {
		fields = append(fields, survey.FieldActiveTime)
	}
	if m.archive_time != nil {
		fields = append(fields, survey.FieldArchiveTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldTitle:
		return m.Title()
	case survey.FieldDescription:
		return m.Description()
	case survey.FieldStatus:
		return m.Status()
	case survey.FieldActiveTime:
		return m.ActiveTime()
	case survey.FieldArchiveTime:
		return m.ArchiveTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case survey.FieldTitle:
		return m.OldTitle(ctx)
	case survey.FieldDescription:
		return m.OldDescription(ctx)
	case survey.FieldStatus:
		return m.OldStatus(ctx)
	case survey.FieldActiveTime:
		return m.OldActiveTime(ctx)
	case survey.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	}
	return nil, fmt.Errorf("unknown Survey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survey.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case survey.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case survey.FieldStatus:
		v, ok := value.(survey.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case survey.FieldActiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTime(v)
		return nil
	case survey.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survey.FieldDescription) {
		fields = append(fields, survey.FieldDescription)
	}
	if m.FieldCleared(survey.FieldActiveTime) {
		fields = append(fields, survey.FieldActiveTime)
	}
	if m.FieldCleared(survey.FieldArchiveTime) {
		fields = append(fields, survey.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyMutation) ClearField(name string) error {
	switch name {
	case survey.FieldDescription:
		m.ClearDescription()
		return nil
	case survey.FieldActiveTime:
		m.ClearActiveTime()
		return nil
	case survey.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown Survey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyMutation) ResetField(name string) error {
	switch name {
	case survey.FieldTitle:
		m.ResetTitle()
		return nil
	case survey.FieldDescription:
		m.ResetDescription()
		return nil
	case survey.FieldStatus:
		m.ResetStatus()
		return nil
	case survey.FieldActiveTime:
		m.ResetActiveTime()
		return nil
	case survey.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prompts != nil {
		edges = append(edges, survey.EdgePrompts)
	}
	if m.feedbacks != nil {
		edges = append(edges, survey.EdgeFeedbacks)
	}
	if m.appointments != nil {
		edges = append(edges, survey.EdgeAppointments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.prompts))
		for id := range m.prompts {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeFeedbacks:
		ids := make([]ent.Value, 0, len(m.feedbacks))
		for id := range m.feedbacks {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.appointments))
		for id := range m.appointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprompts != nil {
		edges = append(edges, survey.EdgePrompts)
	}
	if m.removedfeedbacks != nil {
		edges = append(edges, survey.EdgeFeedbacks)
	}
	if m.removedappointments != nil {
		edges = append(edges, survey.EdgeAppointments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.removedprompts))
		for id := range m.removedprompts {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeFeedbacks:
		ids := make([]ent.Value, 0, len(m.removedfeedbacks))
		for id := range m.removedfeedbacks {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.removedappointments))
		for id := range m.removedappointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprompts {
		edges = append(edges, survey.EdgePrompts)
	}
	if m.clearedfeedbacks {
		edges = append(edges, survey.EdgeFeedbacks)
	}
	if m.clearedappointments {
		edges = append(edges, survey.EdgeAppointments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyMutation) EdgeCleared(name string) bool {
	switch name {
	case survey.EdgePrompts:
		return m.clearedprompts
	case survey.EdgeFeedbacks:
		return m.clearedfeedbacks
	case survey.EdgeAppointments:
		return m.clearedappointments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyMutation) ResetEdge(name string) error {
	switch name {
	case survey.EdgePrompts:
		m.ResetPrompts()
		return nil
	case survey.EdgeFeedbacks:
		m.ResetFeedbacks()
		return nil
	case survey.EdgeAppointments:
		m.ResetAppointments()
		return nil
	}
	return fmt.Errorf("unknown Survey edge %s", name)
}
